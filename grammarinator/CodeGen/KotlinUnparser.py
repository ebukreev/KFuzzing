# Generated by Grammarinator 19.3

from itertools import chain
from random import randint

from grammarinator.runtime import *

import KotlinUnlexer


class KotlinUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(KotlinUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def kotlinFile(self):
        current = self.create_node(UnparserRule(name='kotlinFile'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.preamble()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.anysemi()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.topLevelObject()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        if self.unlexer.max_depth >= 0:
                            for _ in self.one_or_more():
                                current += self.anysemi()

                        if self.unlexer.max_depth >= 4:
                            for _ in self.zero_or_one():
                                current += self.topLevelObject()



        current += self.unlexer.EOF()
        return current
    kotlinFile.min_depth = 2

    @depthcontrol
    def script(self):
        current = self.create_node(UnparserRule(name='script'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.preamble()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.anysemi()

        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.expression()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        if self.unlexer.max_depth >= 0:
                            for _ in self.one_or_more():
                                current += self.anysemi()

                        if self.unlexer.max_depth >= 16:
                            for _ in self.zero_or_one():
                                current += self.expression()



        current += self.unlexer.EOF()
        return current
    script.min_depth = 2

    @depthcontrol
    def preamble(self):
        current = self.create_node(UnparserRule(name='preamble'))
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.fileAnnotations()

        current += self.packageHeader()
        current += self.importList()
        return current
    preamble.min_depth = 1

    @depthcontrol
    def fileAnnotations(self):
        current = self.create_node(UnparserRule(name='fileAnnotations'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.fileAnnotation()

        return current
    fileAnnotations.min_depth = 5

    @depthcontrol
    def fileAnnotation(self):
        current = self.create_node(UnparserRule(name='fileAnnotation'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.FILE()
                current += self.unlexer.COLON()
                choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3361', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3361', choice)] = self.unlexer.weights.get(('alt_3361', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.LSQUARE()
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.unescapedAnnotation()

                    current += self.unlexer.RSQUARE()
                elif choice == 1:
                    current += self.unescapedAnnotation()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.semi()


        return current
    fileAnnotation.min_depth = 4

    @depthcontrol
    def packageHeader(self):
        current = self.create_node(UnparserRule(name='packageHeader'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 4:
                    for _ in self.zero_or_one():
                        current += self.modifierList()

                current += self.unlexer.PACKAGE()
                current += self.identifier()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.semi()


        return current
    packageHeader.min_depth = 0

    @depthcontrol
    def importList(self):
        current = self.create_node(UnparserRule(name='importList'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.importHeader()

        return current
    importList.min_depth = 0

    @depthcontrol
    def importHeader(self):
        current = self.create_node(UnparserRule(name='importHeader'))
        current += self.unlexer.IMPORT()
        current += self.identifier()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3370', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3370', choice)] = self.unlexer.weights.get(('alt_3370', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.DOT()
                    current += self.unlexer.MULT()
                elif choice == 1:
                    current += self.importAlias()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.semi()

        return current
    importHeader.min_depth = 3

    @depthcontrol
    def importAlias(self):
        current = self.create_node(UnparserRule(name='importAlias'))
        current += self.unlexer.AS()
        current += self.simpleIdentifier()
        return current
    importAlias.min_depth = 2

    @depthcontrol
    def topLevelObject(self):
        current = self.create_node(UnparserRule(name='topLevelObject'))
        choice = self.choice([0 if [3, 3, 3, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3374', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3374', choice)] = self.unlexer.weights.get(('alt_3374', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.classDeclaration()
        elif choice == 1:
            current += self.objectDeclaration()
        elif choice == 2:
            current += self.functionDeclaration()
        elif choice == 3:
            current += self.propertyDeclaration()
        elif choice == 4:
            current += self.typeAlias()
        return current
    topLevelObject.min_depth = 3

    @depthcontrol
    def classDeclaration(self):
        current = self.create_node(UnparserRule(name='classDeclaration'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3381', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3381', choice)] = self.unlexer.weights.get(('alt_3381', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.CLASS()
        elif choice == 1:
            current += self.unlexer.INTERFACE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeParameters()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.primaryConstructor()

        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.delegationSpecifiers()

        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeConstraints()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3395', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3395', choice)] = self.unlexer.weights.get(('alt_3395', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.classBody()
                elif choice == 1:
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.enumClassBody()

        return current
    classDeclaration.min_depth = 2

    @depthcontrol
    def primaryConstructor(self):
        current = self.create_node(UnparserRule(name='primaryConstructor'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.CONSTRUCTOR()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()


        current += self.classParameters()
        return current
    primaryConstructor.min_depth = 2

    @depthcontrol
    def classParameters(self):
        current = self.create_node(UnparserRule(name='classParameters'))
        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.classParameter()
                if self.unlexer.max_depth >= 4:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.classParameter()


        current += self.unlexer.RPAREN()
        return current
    classParameters.min_depth = 1

    @depthcontrol
    def classParameter(self):
        current = self.create_node(UnparserRule(name='classParameter'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3407', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3407', choice)] = self.unlexer.weights.get(('alt_3407', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.VAL()
                elif choice == 1:
                    current += self.unlexer.VAR()

        current += self.simpleIdentifier()
        current += self.unlexer.COLON()
        current += self.type_i()
        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.unlexer.ASSIGNMENT()
                current += self.expression()

        return current
    classParameter.min_depth = 3

    @depthcontrol
    def delegationSpecifiers(self):
        current = self.create_node(UnparserRule(name='delegationSpecifiers'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        current += self.delegationSpecifier()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.delegationSpecifier()

        return current
    delegationSpecifiers.min_depth = 5

    @depthcontrol
    def delegationSpecifier(self):
        current = self.create_node(UnparserRule(name='delegationSpecifier'))
        choice = self.choice([0 if [5, 4, 17][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3415', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3415', choice)] = self.unlexer.weights.get(('alt_3415', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.constructorInvocation()
        elif choice == 1:
            current += self.userType()
        elif choice == 2:
            current += self.explicitDelegation()
        return current
    delegationSpecifier.min_depth = 4

    @depthcontrol
    def constructorInvocation(self):
        current = self.create_node(UnparserRule(name='constructorInvocation'))
        current += self.userType()
        current += self.callSuffix()
        return current
    constructorInvocation.min_depth = 4

    @depthcontrol
    def explicitDelegation(self):
        current = self.create_node(UnparserRule(name='explicitDelegation'))
        current += self.userType()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.BY()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.expression()
        return current
    explicitDelegation.min_depth = 16

    @depthcontrol
    def classBody(self):
        current = self.create_node(UnparserRule(name='classBody'))
        current += self.unlexer.LCURL()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.classMemberDeclaration()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.RCURL()
        return current
    classBody.min_depth = 1

    @depthcontrol
    def classMemberDeclaration(self):
        current = self.create_node(UnparserRule(name='classMemberDeclaration'))
        choice = self.choice([0 if [3, 3, 3, 2, 4, 3, 3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3424', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3424', choice)] = self.unlexer.weights.get(('alt_3424', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.classDeclaration()
        elif choice == 1:
            current += self.functionDeclaration()
        elif choice == 2:
            current += self.objectDeclaration()
        elif choice == 3:
            current += self.companionObject()
        elif choice == 4:
            current += self.propertyDeclaration()
        elif choice == 5:
            current += self.anonymousInitializer()
        elif choice == 6:
            current += self.secondaryConstructor()
        elif choice == 7:
            current += self.typeAlias()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.anysemi()

        return current
    classMemberDeclaration.min_depth = 2

    @depthcontrol
    def anonymousInitializer(self):
        current = self.create_node(UnparserRule(name='anonymousInitializer'))
        current += self.unlexer.INIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.block()
        return current
    anonymousInitializer.min_depth = 2

    @depthcontrol
    def secondaryConstructor(self):
        current = self.create_node(UnparserRule(name='secondaryConstructor'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.CONSTRUCTOR()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.functionValueParameters()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.constructorDelegationCall()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.block()
        return current
    secondaryConstructor.min_depth = 2

    @depthcontrol
    def constructorDelegationCall(self):
        current = self.create_node(UnparserRule(name='constructorDelegationCall'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3441', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3441', choice)] = self.unlexer.weights.get(('alt_3441', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.THIS()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.valueArguments()
        elif choice == 1:
            current += self.unlexer.SUPER()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.valueArguments()
        return current
    constructorDelegationCall.min_depth = 2

    @depthcontrol
    def enumClassBody(self):
        current = self.create_node(UnparserRule(name='enumClassBody'))
        current += self.unlexer.LCURL()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.enumEntries()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.SEMICOLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.classMemberDeclaration()


        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.RCURL()
        return current
    enumClassBody.min_depth = 1

    @depthcontrol
    def enumEntries(self):
        current = self.create_node(UnparserRule(name='enumEntries'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.enumEntry()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()


        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        return current
    enumEntries.min_depth = 3

    @depthcontrol
    def enumEntry(self):
        current = self.create_node(UnparserRule(name='enumEntry'))
        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.valueArguments()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.classBody()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()

        return current
    enumEntry.min_depth = 2

    @depthcontrol
    def functionDeclaration(self):
        current = self.create_node(UnparserRule(name='functionDeclaration'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.FUN()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.type_i()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.DOT()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeParameters()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.identifier()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.functionValueParameters()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.type_i()

        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeConstraints()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.functionBody()

        return current
    functionDeclaration.min_depth = 2

    @depthcontrol
    def functionValueParameters(self):
        current = self.create_node(UnparserRule(name='functionValueParameters'))
        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.functionValueParameter()
                if self.unlexer.max_depth >= 5:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.functionValueParameter()


        current += self.unlexer.RPAREN()
        return current
    functionValueParameters.min_depth = 1

    @depthcontrol
    def functionValueParameter(self):
        current = self.create_node(UnparserRule(name='functionValueParameter'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.parameter()
        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.unlexer.ASSIGNMENT()
                current += self.expression()

        return current
    functionValueParameter.min_depth = 4

    @depthcontrol
    def parameter(self):
        current = self.create_node(UnparserRule(name='parameter'))
        current += self.simpleIdentifier()
        current += self.unlexer.COLON()
        current += self.type_i()
        return current
    parameter.min_depth = 3

    @depthcontrol
    def functionBody(self):
        current = self.create_node(UnparserRule(name='functionBody'))
        choice = self.choice([0 if [2, 16][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3481', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3481', choice)] = self.unlexer.weights.get(('alt_3481', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.block()
        elif choice == 1:
            current += self.unlexer.ASSIGNMENT()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.expression()
        return current
    functionBody.min_depth = 2

    @depthcontrol
    def objectDeclaration(self):
        current = self.create_node(UnparserRule(name='objectDeclaration'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.OBJECT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.primaryConstructor()

        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.delegationSpecifiers()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.classBody()

        return current
    objectDeclaration.min_depth = 2

    @depthcontrol
    def companionObject(self):
        current = self.create_node(UnparserRule(name='companionObject'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.COMPANION()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.OBJECT()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.simpleIdentifier()

        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.delegationSpecifiers()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.classBody()

        return current
    companionObject.min_depth = 1

    @depthcontrol
    def propertyDeclaration(self):
        current = self.create_node(UnparserRule(name='propertyDeclaration'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3505', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3505', choice)] = self.unlexer.weights.get(('alt_3505', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.VAL()
        elif choice == 1:
            current += self.unlexer.VAR()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeParameters()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.type_i()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.DOT()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3514', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3514', choice)] = self.unlexer.weights.get(('alt_3514', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.multiVariableDeclaration()
        elif choice == 1:
            current += self.variableDeclaration()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeConstraints()

        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3521', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3521', choice)] = self.unlexer.weights.get(('alt_3521', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.BY()
                elif choice == 1:
                    current += self.unlexer.ASSIGNMENT()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.expression()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3526', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3526', choice)] = self.unlexer.weights.get(('alt_3526', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.getter()
                    if self.unlexer.max_depth >= 2:
                        for _ in self.zero_or_one():
                            current += self.semi()
                            current += self.setter()

                elif choice == 1:
                    current += self.setter()
                    if self.unlexer.max_depth >= 2:
                        for _ in self.zero_or_one():
                            current += self.semi()
                            current += self.getter()


        return current
    propertyDeclaration.min_depth = 3

    @depthcontrol
    def multiVariableDeclaration(self):
        current = self.create_node(UnparserRule(name='multiVariableDeclaration'))
        current += self.unlexer.LPAREN()
        current += self.variableDeclaration()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.variableDeclaration()

        current += self.unlexer.RPAREN()
        return current
    multiVariableDeclaration.min_depth = 3

    @depthcontrol
    def variableDeclaration(self):
        current = self.create_node(UnparserRule(name='variableDeclaration'))
        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.type_i()

        return current
    variableDeclaration.min_depth = 2

    @depthcontrol
    def getter(self):
        current = self.create_node(UnparserRule(name='getter'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3533', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3533', choice)] = self.unlexer.weights.get(('alt_3533', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.modifierList()

            current += self.unlexer.GETTER()
        elif choice == 1:
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.modifierList()

            current += self.unlexer.GETTER()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.LPAREN()
            current += self.unlexer.RPAREN()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.unlexer.COLON()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.type_i()

            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            choice = self.choice([0 if [2, 16][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3543', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_3543', choice)] = self.unlexer.weights.get(('alt_3543', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.block()
            elif choice == 1:
                current += self.unlexer.ASSIGNMENT()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.expression()
        return current
    getter.min_depth = 1

    @depthcontrol
    def setter(self):
        current = self.create_node(UnparserRule(name='setter'))
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3547', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3547', choice)] = self.unlexer.weights.get(('alt_3547', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.modifierList()

            current += self.unlexer.SETTER()
        elif choice == 1:
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.modifierList()

            current += self.unlexer.SETTER()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.LPAREN()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_more():
                    choice = self.choice([0 if [4, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3554', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_3554', choice)] = self.unlexer.weights.get(('alt_3554', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.annotations()
                    elif choice == 1:
                        current += self.parameterModifier()

            choice = self.choice([0 if [2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3557', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_3557', choice)] = self.unlexer.weights.get(('alt_3557', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.simpleIdentifier()
            elif choice == 1:
                current += self.parameter()
            current += self.unlexer.RPAREN()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.functionBody()
        return current
    setter.min_depth = 1

    @depthcontrol
    def typeAlias(self):
        current = self.create_node(UnparserRule(name='typeAlias'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        current += self.unlexer.TYPE_ALIAS()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeParameters()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.ASSIGNMENT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.type_i()
        return current
    typeAlias.min_depth = 3

    @depthcontrol
    def typeParameters(self):
        current = self.create_node(UnparserRule(name='typeParameters'))
        current += self.unlexer.LANGLE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.typeParameter()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeParameter()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.RANGLE()
        return current
    typeParameters.min_depth = 3

    @depthcontrol
    def typeParameter(self):
        current = self.create_node(UnparserRule(name='typeParameter'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.modifierList()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.type_i()

        return current
    typeParameter.min_depth = 2

    @depthcontrol
    def type_i(self):
        current = self.create_node(UnparserRule(name='type_i'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.typeModifierList()

        choice = self.choice([0 if [4, 4, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3578', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_3578', choice)] = self.unlexer.weights.get(('alt_3578', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.functionType()
        elif choice == 1:
            current += self.parenthesizedType()
        elif choice == 2:
            current += self.nullableType()
        elif choice == 3:
            current += self.typeReference()
        return current
    type_i.min_depth = 2

    @depthcontrol
    def typeModifierList(self):
        current = self.create_node(UnparserRule(name='typeModifierList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                choice = self.choice([0 if [4, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3583', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3583', choice)] = self.unlexer.weights.get(('alt_3583', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.annotations()
                elif choice == 1:
                    current += self.unlexer.SUSPEND()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()


        return current
    typeModifierList.min_depth = 1

    @depthcontrol
    def parenthesizedType(self):
        current = self.create_node(UnparserRule(name='parenthesizedType'))
        current += self.unlexer.LPAREN()
        current += self.type_i()
        current += self.unlexer.RPAREN()
        return current
    parenthesizedType.min_depth = 3

    @depthcontrol
    def nullableType(self):
        current = self.create_node(UnparserRule(name='nullableType'))
        choice = self.choice([0 if [2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3587', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3587', choice)] = self.unlexer.weights.get(('alt_3587', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.typeReference()
        elif choice == 1:
            current += self.parenthesizedType()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.QUEST()

        return current
    nullableType.min_depth = 2

    @depthcontrol
    def typeReference(self):
        current = self.create_node(UnparserRule(name='typeReference'))
        choice = self.choice([0 if [2, 4, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3591', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3591', choice)] = self.unlexer.weights.get(('alt_3591', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LPAREN()
            current += self.typeReference()
            current += self.unlexer.RPAREN()
        elif choice == 1:
            current += self.userType()
        elif choice == 2:
            current += self.unlexer.DYNAMIC()
        return current
    typeReference.min_depth = 1

    @depthcontrol
    def functionType(self):
        current = self.create_node(UnparserRule(name='functionType'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.functionTypeReceiver()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.DOT()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()


        current += self.functionTypeParameters()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.ARROW()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.type_i()
        return current
    functionType.min_depth = 3

    @depthcontrol
    def functionTypeReceiver(self):
        current = self.create_node(UnparserRule(name='functionTypeReceiver'))
        choice = self.choice([0 if [4, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3600', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3600', choice)] = self.unlexer.weights.get(('alt_3600', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.parenthesizedType()
        elif choice == 1:
            current += self.nullableType()
        elif choice == 2:
            current += self.typeReference()
        return current
    functionTypeReceiver.min_depth = 2

    @depthcontrol
    def userType(self):
        current = self.create_node(UnparserRule(name='userType'))
        current += self.simpleUserType()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.DOT()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.simpleUserType()

        return current
    userType.min_depth = 3

    @depthcontrol
    def simpleUserType(self):
        current = self.create_node(UnparserRule(name='simpleUserType'))
        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeArguments()

        return current
    simpleUserType.min_depth = 2

    @depthcontrol
    def functionTypeParameters(self):
        current = self.create_node(UnparserRule(name='functionTypeParameters'))
        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3610', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3610', choice)] = self.unlexer.weights.get(('alt_3610', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.parameter()
                elif choice == 1:
                    current += self.type_i()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3614', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3614', choice)] = self.unlexer.weights.get(('alt_3614', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.parameter()
                elif choice == 1:
                    current += self.type_i()

        current += self.unlexer.RPAREN()
        return current
    functionTypeParameters.min_depth = 1

    @depthcontrol
    def typeConstraints(self):
        current = self.create_node(UnparserRule(name='typeConstraints'))
        current += self.unlexer.WHERE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.typeConstraint()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeConstraint()

        return current
    typeConstraints.min_depth = 4

    @depthcontrol
    def typeConstraint(self):
        current = self.create_node(UnparserRule(name='typeConstraint'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        current += self.simpleIdentifier()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.COLON()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.type_i()
        return current
    typeConstraint.min_depth = 3

    @depthcontrol
    def block(self):
        current = self.create_node(UnparserRule(name='block'))
        current += self.unlexer.LCURL()
        current += self.statements()
        current += self.unlexer.RCURL()
        return current
    block.min_depth = 1

    @depthcontrol
    def statements(self):
        current = self.create_node(UnparserRule(name='statements'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.anysemi()

        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.statement()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        if self.unlexer.max_depth >= 0:
                            for _ in self.one_or_more():
                                current += self.anysemi()

                        if self.unlexer.max_depth >= 5:
                            for _ in self.zero_or_one():
                                current += self.statement()



        return current
    statements.min_depth = 0

    @depthcontrol
    def statement(self):
        current = self.create_node(UnparserRule(name='statement'))
        choice = self.choice([0 if [4, 17][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3628', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3628', choice)] = self.unlexer.weights.get(('alt_3628', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.declaration()
        elif choice == 1:
            current += self.blockLevelExpression()
        return current
    statement.min_depth = 4

    @depthcontrol
    def blockLevelExpression(self):
        current = self.create_node(UnparserRule(name='blockLevelExpression'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.expression()
        return current
    blockLevelExpression.min_depth = 16

    @depthcontrol
    def declaration(self):
        current = self.create_node(UnparserRule(name='declaration'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.labelDefinition()

        choice = self.choice([0 if [3, 3, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3634', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_3634', choice)] = self.unlexer.weights.get(('alt_3634', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.classDeclaration()
        elif choice == 1:
            current += self.functionDeclaration()
        elif choice == 2:
            current += self.propertyDeclaration()
        elif choice == 3:
            current += self.typeAlias()
        return current
    declaration.min_depth = 3

    @depthcontrol
    def expression(self):
        current = self.create_node(UnparserRule(name='expression'))
        current += self.disjunction()
        if self.unlexer.max_depth >= 15:
            for _ in self.zero_or_more():
                current += self.assignmentOperator()
                current += self.disjunction()

        return current
    expression.min_depth = 15

    @depthcontrol
    def disjunction(self):
        current = self.create_node(UnparserRule(name='disjunction'))
        current += self.conjunction()
        if self.unlexer.max_depth >= 14:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.DISJ()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.conjunction()

        return current
    disjunction.min_depth = 14

    @depthcontrol
    def conjunction(self):
        current = self.create_node(UnparserRule(name='conjunction'))
        current += self.equalityComparison()
        if self.unlexer.max_depth >= 13:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.CONJ()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.equalityComparison()

        return current
    conjunction.min_depth = 13

    @depthcontrol
    def equalityComparison(self):
        current = self.create_node(UnparserRule(name='equalityComparison'))
        current += self.comparison()
        if self.unlexer.max_depth >= 12:
            for _ in self.zero_or_more():
                current += self.equalityOperation()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.comparison()

        return current
    equalityComparison.min_depth = 12

    @depthcontrol
    def comparison(self):
        current = self.create_node(UnparserRule(name='comparison'))
        current += self.namedInfix()
        if self.unlexer.max_depth >= 11:
            for _ in self.zero_or_one():
                current += self.comparisonOperator()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.namedInfix()

        return current
    comparison.min_depth = 11

    @depthcontrol
    def namedInfix(self):
        current = self.create_node(UnparserRule(name='namedInfix'))
        current += self.elvisExpression()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [10, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3651', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3651', choice)] = self.unlexer.weights.get(('alt_3651', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.inOperator()
                            if self.unlexer.max_depth >= 1:
                                for _ in self.zero_or_more():
                                    current += self.unlexer.NL()

                            current += self.elvisExpression()

                elif choice == 1:
                    current += self.isOperator()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.type_i()

        return current
    namedInfix.min_depth = 10

    @depthcontrol
    def elvisExpression(self):
        current = self.create_node(UnparserRule(name='elvisExpression'))
        current += self.infixFunctionCall()
        if self.unlexer.max_depth >= 9:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.ELVIS()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.infixFunctionCall()

        return current
    elvisExpression.min_depth = 9

    @depthcontrol
    def infixFunctionCall(self):
        current = self.create_node(UnparserRule(name='infixFunctionCall'))
        current += self.rangeExpression()
        if self.unlexer.max_depth >= 8:
            for _ in self.zero_or_more():
                current += self.simpleIdentifier()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.rangeExpression()

        return current
    infixFunctionCall.min_depth = 8

    @depthcontrol
    def rangeExpression(self):
        current = self.create_node(UnparserRule(name='rangeExpression'))
        current += self.additiveExpression()
        if self.unlexer.max_depth >= 7:
            for _ in self.zero_or_more():
                current += self.unlexer.RANGE()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.additiveExpression()

        return current
    rangeExpression.min_depth = 7

    @depthcontrol
    def additiveExpression(self):
        current = self.create_node(UnparserRule(name='additiveExpression'))
        current += self.multiplicativeExpression()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_more():
                current += self.additiveOperator()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.multiplicativeExpression()

        return current
    additiveExpression.min_depth = 6

    @depthcontrol
    def multiplicativeExpression(self):
        current = self.create_node(UnparserRule(name='multiplicativeExpression'))
        current += self.typeRHS()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                current += self.multiplicativeOperation()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeRHS()

        return current
    multiplicativeExpression.min_depth = 5

    @depthcontrol
    def typeRHS(self):
        current = self.create_node(UnparserRule(name='typeRHS'))
        current += self.prefixUnaryExpression()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.typeOperation()
                current += self.prefixUnaryExpression()

        return current
    typeRHS.min_depth = 4

    @depthcontrol
    def prefixUnaryExpression(self):
        current = self.create_node(UnparserRule(name='prefixUnaryExpression'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.prefixUnaryOperation()

        current += self.postfixUnaryExpression()
        return current
    prefixUnaryExpression.min_depth = 3

    @depthcontrol
    def postfixUnaryExpression(self):
        current = self.create_node(UnparserRule(name='postfixUnaryExpression'))
        choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3670', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3670', choice)] = self.unlexer.weights.get(('alt_3670', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.atomicExpression()
        elif choice == 1:
            current += self.callableReference()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.postfixUnaryOperation()

        return current
    postfixUnaryExpression.min_depth = 2

    @depthcontrol
    def atomicExpression(self):
        current = self.create_node(UnparserRule(name='atomicExpression'))
        choice = self.choice([0 if [17, 2, 2, 2, 2, 3, 3, 3, 2, 18, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3674', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3674', choice)] = self.unlexer.weights.get(('alt_3674', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.parenthesizedExpression()
        elif choice == 1:
            current += self.literalConstant()
        elif choice == 2:
            current += self.functionLiteral()
        elif choice == 3:
            current += self.thisExpression()
        elif choice == 4:
            current += self.superExpression()
        elif choice == 5:
            current += self.conditionalExpression()
        elif choice == 6:
            current += self.tryExpression()
        elif choice == 7:
            current += self.objectLiteral()
        elif choice == 8:
            current += self.jumpExpression()
        elif choice == 9:
            current += self.loopExpression()
        elif choice == 10:
            current += self.collectionLiteral()
        elif choice == 11:
            current += self.simpleIdentifier()
        return current
    atomicExpression.min_depth = 2

    @depthcontrol
    def parenthesizedExpression(self):
        current = self.create_node(UnparserRule(name='parenthesizedExpression'))
        current += self.unlexer.LPAREN()
        current += self.expression()
        current += self.unlexer.RPAREN()
        return current
    parenthesizedExpression.min_depth = 16

    @depthcontrol
    def callSuffix(self):
        current = self.create_node(UnparserRule(name='callSuffix'))
        choice = self.choice([0 if [3, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3687', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3687', choice)] = self.unlexer.weights.get(('alt_3687', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.typeArguments()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.valueArguments()

            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.annotatedLambda()

        elif choice == 1:
            current += self.valueArguments()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.annotatedLambda()

        elif choice == 2:
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.annotatedLambda()

        return current
    callSuffix.min_depth = 2

    @depthcontrol
    def annotatedLambda(self):
        current = self.create_node(UnparserRule(name='annotatedLambda'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unescapedAnnotation()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.LabelDefinition()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.functionLiteral()
        return current
    annotatedLambda.min_depth = 2

    @depthcontrol
    def arrayAccess(self):
        current = self.create_node(UnparserRule(name='arrayAccess'))
        current += self.unlexer.LSQUARE()
        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.expression()
                if self.unlexer.max_depth >= 16:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.expression()


        current += self.unlexer.RSQUARE()
        return current
    arrayAccess.min_depth = 1

    @depthcontrol
    def valueArguments(self):
        current = self.create_node(UnparserRule(name='valueArguments'))
        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 17:
            for _ in self.zero_or_one():
                current += self.valueArgument()
                if self.unlexer.max_depth >= 17:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.valueArgument()


        current += self.unlexer.RPAREN()
        return current
    valueArguments.min_depth = 1

    @depthcontrol
    def typeArguments(self):
        current = self.create_node(UnparserRule(name='typeArguments'))
        current += self.unlexer.LANGLE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.typeProjection()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()
                current += self.typeProjection()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.RANGLE()
        return current
    typeArguments.min_depth = 2

    @depthcontrol
    def typeProjection(self):
        current = self.create_node(UnparserRule(name='typeProjection'))
        choice = self.choice([0 if [3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3705', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3705', choice)] = self.unlexer.weights.get(('alt_3705', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.typeProjectionModifierList()

            current += self.type_i()
        elif choice == 1:
            current += self.unlexer.MULT()
        return current
    typeProjection.min_depth = 1

    @depthcontrol
    def typeProjectionModifierList(self):
        current = self.create_node(UnparserRule(name='typeProjectionModifierList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.varianceAnnotation()

        return current
    typeProjectionModifierList.min_depth = 2

    @depthcontrol
    def valueArgument(self):
        current = self.create_node(UnparserRule(name='valueArgument'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.simpleIdentifier()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.ASSIGNMENT()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()


        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.MULT()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.expression()
        return current
    valueArgument.min_depth = 16

    @depthcontrol
    def literalConstant(self):
        current = self.create_node(UnparserRule(name='literalConstant'))
        choice = self.choice([0 if [1, 1, 3, 2, 2, 1, 3, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3714', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3714', choice)] = self.unlexer.weights.get(('alt_3714', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BooleanLiteral()
        elif choice == 1:
            current += self.unlexer.IntegerLiteral()
        elif choice == 2:
            current += self.stringLiteral()
        elif choice == 3:
            current += self.unlexer.HexLiteral()
        elif choice == 4:
            current += self.unlexer.BinLiteral()
        elif choice == 5:
            current += self.unlexer.CharacterLiteral()
        elif choice == 6:
            current += self.unlexer.RealLiteral()
        elif choice == 7:
            current += self.unlexer.NullLiteral()
        elif choice == 8:
            current += self.unlexer.LongLiteral()
        return current
    literalConstant.min_depth = 1

    @depthcontrol
    def stringLiteral(self):
        current = self.create_node(UnparserRule(name='stringLiteral'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3724', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3724', choice)] = self.unlexer.weights.get(('alt_3724', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.lineStringLiteral()
        elif choice == 1:
            current += self.multiLineStringLiteral()
        return current
    stringLiteral.min_depth = 2

    @depthcontrol
    def lineStringLiteral(self):
        current = self.create_node(UnparserRule(name='lineStringLiteral'))
        current += self.unlexer.QUOTE_OPEN()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 17][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3728', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3728', choice)] = self.unlexer.weights.get(('alt_3728', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.lineStringContent()
                elif choice == 1:
                    current += self.lineStringExpression()

        current += self.unlexer.QUOTE_CLOSE()
        return current
    lineStringLiteral.min_depth = 1

    @depthcontrol
    def multiLineStringLiteral(self):
        current = self.create_node(UnparserRule(name='multiLineStringLiteral'))
        current += self.unlexer.TRIPLE_QUOTE_OPEN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 17, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3732', i), 1) for i, w in enumerate([1, 1, 1, 1])])
                self.unlexer.weights[('alt_3732', choice)] = self.unlexer.weights.get(('alt_3732', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.multiLineStringContent()
                elif choice == 1:
                    current += self.multiLineStringExpression()
                elif choice == 2:
                    current += self.lineStringLiteral()
                elif choice == 3:
                    current += self.unlexer.MultiLineStringQuote()

        current += self.unlexer.TRIPLE_QUOTE_CLOSE()
        return current
    multiLineStringLiteral.min_depth = 1

    @depthcontrol
    def lineStringContent(self):
        current = self.create_node(UnparserRule(name='lineStringContent'))
        choice = self.choice([0 if [1, 1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3737', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3737', choice)] = self.unlexer.weights.get(('alt_3737', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LineStrText()
        elif choice == 1:
            current += self.unlexer.LineStrEscapedChar()
        elif choice == 2:
            current += self.unlexer.LineStrRef()
        return current
    lineStringContent.min_depth = 1

    @depthcontrol
    def lineStringExpression(self):
        current = self.create_node(UnparserRule(name='lineStringExpression'))
        current += self.unlexer.LineStrExprStart()
        current += self.expression()
        current += self.unlexer.RCURL()
        return current
    lineStringExpression.min_depth = 16

    @depthcontrol
    def multiLineStringContent(self):
        current = self.create_node(UnparserRule(name='multiLineStringContent'))
        choice = self.choice([0 if [1, 1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3741', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3741', choice)] = self.unlexer.weights.get(('alt_3741', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.MultiLineStrText()
        elif choice == 1:
            current += self.unlexer.MultiLineStrEscapedChar()
        elif choice == 2:
            current += self.unlexer.MultiLineStrRef()
        return current
    multiLineStringContent.min_depth = 1

    @depthcontrol
    def multiLineStringExpression(self):
        current = self.create_node(UnparserRule(name='multiLineStringExpression'))
        current += self.unlexer.MultiLineStrExprStart()
        current += self.expression()
        current += self.unlexer.RCURL()
        return current
    multiLineStringExpression.min_depth = 16

    @depthcontrol
    def functionLiteral(self):
        current = self.create_node(UnparserRule(name='functionLiteral'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3746', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3746', choice)] = self.unlexer.weights.get(('alt_3746', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LCURL()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.statements()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.RCURL()
        elif choice == 1:
            current += self.unlexer.LCURL()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.lambdaParameters()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.ARROW()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.statements()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.RCURL()
        return current
    functionLiteral.min_depth = 1

    @depthcontrol
    def lambdaParameters(self):
        current = self.create_node(UnparserRule(name='lambdaParameters'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.lambdaParameter()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COMMA()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.lambdaParameter()

        return current
    lambdaParameters.min_depth = 0

    @depthcontrol
    def lambdaParameter(self):
        current = self.create_node(UnparserRule(name='lambdaParameter'))
        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3759', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3759', choice)] = self.unlexer.weights.get(('alt_3759', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.variableDeclaration()
        elif choice == 1:
            current += self.multiVariableDeclaration()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.unlexer.COLON()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.type_i()

        return current
    lambdaParameter.min_depth = 3

    @depthcontrol
    def objectLiteral(self):
        current = self.create_node(UnparserRule(name='objectLiteral'))
        current += self.unlexer.OBJECT()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.COLON()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.delegationSpecifiers()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.classBody()
        return current
    objectLiteral.min_depth = 2

    @depthcontrol
    def collectionLiteral(self):
        current = self.create_node(UnparserRule(name='collectionLiteral'))
        current += self.unlexer.LSQUARE()
        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.expression()

        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.expression()

        current += self.unlexer.RSQUARE()
        return current
    collectionLiteral.min_depth = 1

    @depthcontrol
    def thisExpression(self):
        current = self.create_node(UnparserRule(name='thisExpression'))
        current += self.unlexer.THIS()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.LabelReference()

        return current
    thisExpression.min_depth = 1

    @depthcontrol
    def superExpression(self):
        current = self.create_node(UnparserRule(name='superExpression'))
        current += self.unlexer.SUPER()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.LANGLE()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.type_i()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.RANGLE()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.LabelReference()

        return current
    superExpression.min_depth = 1

    @depthcontrol
    def conditionalExpression(self):
        current = self.create_node(UnparserRule(name='conditionalExpression'))
        choice = self.choice([0 if [17, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3776', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3776', choice)] = self.unlexer.weights.get(('alt_3776', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.ifExpression()
        elif choice == 1:
            current += self.whenExpression()
        return current
    conditionalExpression.min_depth = 2

    @depthcontrol
    def ifExpression(self):
        current = self.create_node(UnparserRule(name='ifExpression'))
        current += self.unlexer.IF()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LPAREN()
        current += self.expression()
        current += self.unlexer.RPAREN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.controlStructureBody()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.unlexer.ELSE()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_one():
                        current += self.controlStructureBody()


        return current
    ifExpression.min_depth = 16

    @depthcontrol
    def controlStructureBody(self):
        current = self.create_node(UnparserRule(name='controlStructureBody'))
        choice = self.choice([0 if [2, 16][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3787', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3787', choice)] = self.unlexer.weights.get(('alt_3787', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.block()
        elif choice == 1:
            current += self.expression()
        return current
    controlStructureBody.min_depth = 2

    @depthcontrol
    def whenExpression(self):
        current = self.create_node(UnparserRule(name='whenExpression'))
        current += self.unlexer.WHEN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 16:
            for _ in self.zero_or_one():
                current += self.unlexer.LPAREN()
                current += self.expression()
                current += self.unlexer.RPAREN()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LCURL()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.whenEntry()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()


        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.RCURL()
        return current
    whenExpression.min_depth = 1

    @depthcontrol
    def whenEntry(self):
        current = self.create_node(UnparserRule(name='whenEntry'))
        choice = self.choice([0 if [5, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3797', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3797', choice)] = self.unlexer.weights.get(('alt_3797', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.whenCondition()
            if self.unlexer.max_depth >= 5:
                for _ in self.zero_or_more():
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.unlexer.COMMA()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.whenCondition()

            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.ARROW()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.controlStructureBody()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.semi()

        elif choice == 1:
            current += self.unlexer.ELSE()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.ARROW()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.controlStructureBody()
        return current
    whenEntry.min_depth = 3

    @depthcontrol
    def whenCondition(self):
        current = self.create_node(UnparserRule(name='whenCondition'))
        choice = self.choice([0 if [16, 17, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3808', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3808', choice)] = self.unlexer.weights.get(('alt_3808', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.expression()
        elif choice == 1:
            current += self.rangeTest()
        elif choice == 2:
            current += self.typeTest()
        return current
    whenCondition.min_depth = 4

    @depthcontrol
    def rangeTest(self):
        current = self.create_node(UnparserRule(name='rangeTest'))
        current += self.inOperator()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.expression()
        return current
    rangeTest.min_depth = 16

    @depthcontrol
    def typeTest(self):
        current = self.create_node(UnparserRule(name='typeTest'))
        current += self.isOperator()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.type_i()
        return current
    typeTest.min_depth = 3

    @depthcontrol
    def tryExpression(self):
        current = self.create_node(UnparserRule(name='tryExpression'))
        current += self.unlexer.TRY()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.block()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.catchBlock()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.NL()

                current += self.finallyBlock()

        return current
    tryExpression.min_depth = 2

    @depthcontrol
    def catchBlock(self):
        current = self.create_node(UnparserRule(name='catchBlock'))
        current += self.unlexer.CATCH()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        current += self.simpleIdentifier()
        current += self.unlexer.COLON()
        current += self.userType()
        current += self.unlexer.RPAREN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.block()
        return current
    catchBlock.min_depth = 4

    @depthcontrol
    def finallyBlock(self):
        current = self.create_node(UnparserRule(name='finallyBlock'))
        current += self.unlexer.FINALLY()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.block()
        return current
    finallyBlock.min_depth = 2

    @depthcontrol
    def loopExpression(self):
        current = self.create_node(UnparserRule(name='loopExpression'))
        choice = self.choice([0 if [17, 17, 17][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3823', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3823', choice)] = self.unlexer.weights.get(('alt_3823', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.forExpression()
        elif choice == 1:
            current += self.whileExpression()
        elif choice == 2:
            current += self.doWhileExpression()
        return current
    loopExpression.min_depth = 17

    @depthcontrol
    def forExpression(self):
        current = self.create_node(UnparserRule(name='forExpression'))
        current += self.unlexer.FOR()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.annotations()

        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3829', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3829', choice)] = self.unlexer.weights.get(('alt_3829', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.variableDeclaration()
        elif choice == 1:
            current += self.multiVariableDeclaration()
        current += self.unlexer.IN()
        current += self.expression()
        current += self.unlexer.RPAREN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.controlStructureBody()

        return current
    forExpression.min_depth = 16

    @depthcontrol
    def whileExpression(self):
        current = self.create_node(UnparserRule(name='whileExpression'))
        current += self.unlexer.WHILE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LPAREN()
        current += self.expression()
        current += self.unlexer.RPAREN()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.controlStructureBody()

        return current
    whileExpression.min_depth = 16

    @depthcontrol
    def doWhileExpression(self):
        current = self.create_node(UnparserRule(name='doWhileExpression'))
        current += self.unlexer.DO()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.controlStructureBody()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.WHILE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        current += self.unlexer.LPAREN()
        current += self.expression()
        current += self.unlexer.RPAREN()
        return current
    doWhileExpression.min_depth = 16

    @depthcontrol
    def jumpExpression(self):
        current = self.create_node(UnparserRule(name='jumpExpression'))
        choice = self.choice([0 if [16, 1, 1, 2, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3841', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3841', choice)] = self.unlexer.weights.get(('alt_3841', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.THROW()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.expression()
        elif choice == 1:
            choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3849', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_3849', choice)] = self.unlexer.weights.get(('alt_3849', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.RETURN()
            elif choice == 1:
                current += self.unlexer.RETURN_AT()
            if self.unlexer.max_depth >= 16:
                for _ in self.zero_or_one():
                    current += self.expression()

        elif choice == 2:
            current += self.unlexer.CONTINUE()
        elif choice == 3:
            current += self.unlexer.CONTINUE_AT()
        elif choice == 4:
            current += self.unlexer.BREAK()
        elif choice == 5:
            current += self.unlexer.BREAK_AT()
        return current
    jumpExpression.min_depth = 1

    @depthcontrol
    def callableReference(self):
        current = self.create_node(UnparserRule(name='callableReference'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.userType()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_more():
                        current += self.unlexer.QUEST()
                        if self.unlexer.max_depth >= 1:
                            for _ in self.zero_or_more():
                                current += self.unlexer.NL()



        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3857', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3857', choice)] = self.unlexer.weights.get(('alt_3857', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.COLONCOLON()
        elif choice == 1:
            current += self.unlexer.Q_COLONCOLON()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        choice = self.choice([0 if [3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3861', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3861', choice)] = self.unlexer.weights.get(('alt_3861', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifier()
        elif choice == 1:
            current += self.unlexer.CLASS()
        return current
    callableReference.min_depth = 1

    @depthcontrol
    def assignmentOperator(self):
        current = self.create_node(UnparserRule(name='assignmentOperator'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3864', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3864', choice)] = self.unlexer.weights.get(('alt_3864', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ASSIGNMENT()
        elif choice == 1:
            current += self.unlexer.ADD_ASSIGNMENT()
        elif choice == 2:
            current += self.unlexer.SUB_ASSIGNMENT()
        elif choice == 3:
            current += self.unlexer.MULT_ASSIGNMENT()
        elif choice == 4:
            current += self.unlexer.DIV_ASSIGNMENT()
        elif choice == 5:
            current += self.unlexer.MOD_ASSIGNMENT()
        return current
    assignmentOperator.min_depth = 1

    @depthcontrol
    def equalityOperation(self):
        current = self.create_node(UnparserRule(name='equalityOperation'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3871', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_3871', choice)] = self.unlexer.weights.get(('alt_3871', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.EXCL_EQ()
        elif choice == 1:
            current += self.unlexer.EXCL_EQEQ()
        elif choice == 2:
            current += self.unlexer.EQEQ()
        elif choice == 3:
            current += self.unlexer.EQEQEQ()
        return current
    equalityOperation.min_depth = 1

    @depthcontrol
    def comparisonOperator(self):
        current = self.create_node(UnparserRule(name='comparisonOperator'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3876', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_3876', choice)] = self.unlexer.weights.get(('alt_3876', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LANGLE()
        elif choice == 1:
            current += self.unlexer.RANGLE()
        elif choice == 2:
            current += self.unlexer.LE()
        elif choice == 3:
            current += self.unlexer.GE()
        return current
    comparisonOperator.min_depth = 1

    @depthcontrol
    def inOperator(self):
        current = self.create_node(UnparserRule(name='inOperator'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3881', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3881', choice)] = self.unlexer.weights.get(('alt_3881', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.IN()
        elif choice == 1:
            current += self.unlexer.NOT_IN()
        return current
    inOperator.min_depth = 1

    @depthcontrol
    def isOperator(self):
        current = self.create_node(UnparserRule(name='isOperator'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3884', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3884', choice)] = self.unlexer.weights.get(('alt_3884', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.IS()
        elif choice == 1:
            current += self.unlexer.NOT_IS()
        return current
    isOperator.min_depth = 1

    @depthcontrol
    def additiveOperator(self):
        current = self.create_node(UnparserRule(name='additiveOperator'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3887', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3887', choice)] = self.unlexer.weights.get(('alt_3887', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ADD()
        elif choice == 1:
            current += self.unlexer.SUB()
        return current
    additiveOperator.min_depth = 1

    @depthcontrol
    def multiplicativeOperation(self):
        current = self.create_node(UnparserRule(name='multiplicativeOperation'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3890', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3890', choice)] = self.unlexer.weights.get(('alt_3890', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.MULT()
        elif choice == 1:
            current += self.unlexer.DIV()
        elif choice == 2:
            current += self.unlexer.MOD()
        return current
    multiplicativeOperation.min_depth = 1

    @depthcontrol
    def typeOperation(self):
        current = self.create_node(UnparserRule(name='typeOperation'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3894', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3894', choice)] = self.unlexer.weights.get(('alt_3894', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.AS()
        elif choice == 1:
            current += self.unlexer.AS_SAFE()
        elif choice == 2:
            current += self.unlexer.COLON()
        return current
    typeOperation.min_depth = 1

    @depthcontrol
    def prefixUnaryOperation(self):
        current = self.create_node(UnparserRule(name='prefixUnaryOperation'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3898', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3898', choice)] = self.unlexer.weights.get(('alt_3898', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INCR()
        elif choice == 1:
            current += self.unlexer.DECR()
        elif choice == 2:
            current += self.unlexer.ADD()
        elif choice == 3:
            current += self.unlexer.SUB()
        elif choice == 4:
            current += self.unlexer.EXCL()
        elif choice == 5:
            current += self.annotations()
        elif choice == 6:
            current += self.labelDefinition()
        return current
    prefixUnaryOperation.min_depth = 1

    @depthcontrol
    def postfixUnaryOperation(self):
        current = self.create_node(UnparserRule(name='postfixUnaryOperation'))
        choice = self.choice([0 if [1, 1, 1, 3, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3906', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3906', choice)] = self.unlexer.weights.get(('alt_3906', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INCR()
        elif choice == 1:
            current += self.unlexer.DECR()
        elif choice == 2:
            current += self.unlexer.EXCL()
            current += self.unlexer.EXCL()
        elif choice == 3:
            current += self.callSuffix()
        elif choice == 4:
            current += self.arrayAccess()
        elif choice == 5:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.memberAccessOperator()
            current += self.postfixUnaryExpression()
        return current
    postfixUnaryOperation.min_depth = 1

    @depthcontrol
    def memberAccessOperator(self):
        current = self.create_node(UnparserRule(name='memberAccessOperator'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3914', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3914', choice)] = self.unlexer.weights.get(('alt_3914', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.DOT()
        elif choice == 1:
            current += self.unlexer.QUEST()
            current += self.unlexer.DOT()
        return current
    memberAccessOperator.min_depth = 1

    @depthcontrol
    def modifierList(self):
        current = self.create_node(UnparserRule(name='modifierList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3917', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_3917', choice)] = self.unlexer.weights.get(('alt_3917', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.annotations()
                elif choice == 1:
                    current += self.modifier()

        return current
    modifierList.min_depth = 3

    @depthcontrol
    def modifier(self):
        current = self.create_node(UnparserRule(name='modifier'))
        choice = self.choice([0 if [2, 2, 2, 2, 2, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3920', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3920', choice)] = self.unlexer.weights.get(('alt_3920', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.classModifier()
        elif choice == 1:
            current += self.memberModifier()
        elif choice == 2:
            current += self.visibilityModifier()
        elif choice == 3:
            current += self.varianceAnnotation()
        elif choice == 4:
            current += self.functionModifier()
        elif choice == 5:
            current += self.propertyModifier()
        elif choice == 6:
            current += self.inheritanceModifier()
        elif choice == 7:
            current += self.parameterModifier()
        elif choice == 8:
            current += self.typeParameterModifier()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        return current
    modifier.min_depth = 2

    @depthcontrol
    def classModifier(self):
        current = self.create_node(UnparserRule(name='classModifier'))
        choice = self.choice([0 if [1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3931', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3931', choice)] = self.unlexer.weights.get(('alt_3931', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ENUM()
        elif choice == 1:
            current += self.unlexer.SEALED()
        elif choice == 2:
            current += self.unlexer.ANNOTATION()
        elif choice == 3:
            current += self.unlexer.DATA()
        elif choice == 4:
            current += self.unlexer.INNER()
        return current
    classModifier.min_depth = 1

    @depthcontrol
    def memberModifier(self):
        current = self.create_node(UnparserRule(name='memberModifier'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3937', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3937', choice)] = self.unlexer.weights.get(('alt_3937', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.OVERRIDE()
        elif choice == 1:
            current += self.unlexer.LATEINIT()
        return current
    memberModifier.min_depth = 1

    @depthcontrol
    def visibilityModifier(self):
        current = self.create_node(UnparserRule(name='visibilityModifier'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3940', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_3940', choice)] = self.unlexer.weights.get(('alt_3940', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.PUBLIC()
        elif choice == 1:
            current += self.unlexer.PRIVATE()
        elif choice == 2:
            current += self.unlexer.INTERNAL()
        elif choice == 3:
            current += self.unlexer.PROTECTED()
        return current
    visibilityModifier.min_depth = 1

    @depthcontrol
    def varianceAnnotation(self):
        current = self.create_node(UnparserRule(name='varianceAnnotation'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3945', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3945', choice)] = self.unlexer.weights.get(('alt_3945', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.IN()
        elif choice == 1:
            current += self.unlexer.OUT()
        return current
    varianceAnnotation.min_depth = 1

    @depthcontrol
    def functionModifier(self):
        current = self.create_node(UnparserRule(name='functionModifier'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3948', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3948', choice)] = self.unlexer.weights.get(('alt_3948', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TAILREC()
        elif choice == 1:
            current += self.unlexer.OPERATOR()
        elif choice == 2:
            current += self.unlexer.INFIX()
        elif choice == 3:
            current += self.unlexer.INLINE()
        elif choice == 4:
            current += self.unlexer.EXTERNAL()
        elif choice == 5:
            current += self.unlexer.SUSPEND()
        return current
    functionModifier.min_depth = 1

    @depthcontrol
    def propertyModifier(self):
        current = self.create_node(UnparserRule(name='propertyModifier'))
        current += self.unlexer.CONST()
        return current
    propertyModifier.min_depth = 1

    @depthcontrol
    def inheritanceModifier(self):
        current = self.create_node(UnparserRule(name='inheritanceModifier'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3955', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3955', choice)] = self.unlexer.weights.get(('alt_3955', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ABSTRACT()
        elif choice == 1:
            current += self.unlexer.FINAL()
        elif choice == 2:
            current += self.unlexer.OPEN()
        return current
    inheritanceModifier.min_depth = 1

    @depthcontrol
    def parameterModifier(self):
        current = self.create_node(UnparserRule(name='parameterModifier'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3959', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_3959', choice)] = self.unlexer.weights.get(('alt_3959', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.VARARG()
        elif choice == 1:
            current += self.unlexer.NOINLINE()
        elif choice == 2:
            current += self.unlexer.CROSSINLINE()
        return current
    parameterModifier.min_depth = 1

    @depthcontrol
    def typeParameterModifier(self):
        current = self.create_node(UnparserRule(name='typeParameterModifier'))
        current += self.unlexer.REIFIED()
        return current
    typeParameterModifier.min_depth = 1

    @depthcontrol
    def labelDefinition(self):
        current = self.create_node(UnparserRule(name='labelDefinition'))
        current += self.unlexer.LabelDefinition()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        return current
    labelDefinition.min_depth = 2

    @depthcontrol
    def annotations(self):
        current = self.create_node(UnparserRule(name='annotations'))
        choice = self.choice([0 if [3, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3964', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3964', choice)] = self.unlexer.weights.get(('alt_3964', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.annotation()
        elif choice == 1:
            current += self.annotationList()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.NL()

        return current
    annotations.min_depth = 3

    @depthcontrol
    def annotation(self):
        current = self.create_node(UnparserRule(name='annotation'))
        choice = self.choice([0 if [4, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3968', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3968', choice)] = self.unlexer.weights.get(('alt_3968', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.annotationUseSiteTarget()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.COLON()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unescapedAnnotation()
        elif choice == 1:
            current += self.unlexer.LabelReference()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.typeArguments()

            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_more():
                            current += self.unlexer.NL()

                    current += self.valueArguments()

        return current
    annotation.min_depth = 2

    @depthcontrol
    def annotationList(self):
        current = self.create_node(UnparserRule(name='annotationList'))
        choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3977', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_3977', choice)] = self.unlexer.weights.get(('alt_3977', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.annotationUseSiteTarget()
            current += self.unlexer.COLON()
            current += self.unlexer.LSQUARE()
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unescapedAnnotation()

            current += self.unlexer.RSQUARE()
        elif choice == 1:
            current += self.unlexer.AT()
            current += self.unlexer.LSQUARE()
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unescapedAnnotation()

            current += self.unlexer.RSQUARE()
        return current
    annotationList.min_depth = 4

    @depthcontrol
    def annotationUseSiteTarget(self):
        current = self.create_node(UnparserRule(name='annotationUseSiteTarget'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3980', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3980', choice)] = self.unlexer.weights.get(('alt_3980', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.FIELD()
        elif choice == 1:
            current += self.unlexer.FILE()
        elif choice == 2:
            current += self.unlexer.PROPERTY()
        elif choice == 3:
            current += self.unlexer.GET()
        elif choice == 4:
            current += self.unlexer.SET()
        elif choice == 5:
            current += self.unlexer.RECEIVER()
        elif choice == 6:
            current += self.unlexer.PARAM()
        elif choice == 7:
            current += self.unlexer.SETPARAM()
        elif choice == 8:
            current += self.unlexer.DELEGATE()
        return current
    annotationUseSiteTarget.min_depth = 1

    @depthcontrol
    def unescapedAnnotation(self):
        current = self.create_node(UnparserRule(name='unescapedAnnotation'))
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.typeArguments()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.valueArguments()

        return current
    unescapedAnnotation.min_depth = 3

    @depthcontrol
    def identifier(self):
        current = self.create_node(UnparserRule(name='identifier'))
        if randint(0, 6) == 1:
            current += self.simpleIdentifier()
            current += self.unlexer.DOT()
            current += self.simpleIdentifier()
        else:
            current += self.simpleIdentifier()
        # if self.unlexer.max_depth >= 2:
        #     for _ in self.zero_or_more():
        #         if self.unlexer.max_depth >= 1:
        #             for _ in self.zero_or_more():
        #                 current += self.unlexer.NL()
        #
        #         current += self.unlexer.DOT()
        #         current += self.simpleIdentifier()

        return current
    identifier.min_depth = 2

    @depthcontrol
    def simpleIdentifier(self):
        current = self.create_node(UnparserRule(name='simpleIdentifier'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_3994', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_3994', choice)] = self.unlexer.weights.get(('alt_3994', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Identifier()
        elif choice == 1:
            current += self.unlexer.Identifier()
        elif choice == 2:
            current += self.unlexer.Identifier()
        elif choice == 3:
            current += self.unlexer.Identifier()
        elif choice == 4:
            current += self.unlexer.Identifier()
        elif choice == 5:
            current += self.unlexer.Identifier()
        elif choice == 6:
            current += self.unlexer.Identifier()
        elif choice == 7:
            current += self.unlexer.Identifier()
        elif choice == 8:
            current += self.unlexer.Identifier()
        elif choice == 9:
            current += self.unlexer.Identifier()
        elif choice == 10:
            current += self.unlexer.Identifier()
        elif choice == 11:
            current += self.unlexer.Identifier()
        elif choice == 12:
            current += self.unlexer.Identifier()
        elif choice == 13:
            current += self.unlexer.Identifier()
        elif choice == 14:
            current += self.unlexer.Identifier()
        elif choice == 15:
            current += self.unlexer.Identifier()
        elif choice == 16:
            current += self.unlexer.Identifier()
        elif choice == 17:
            current += self.unlexer.Identifier()
        elif choice == 18:
            current += self.unlexer.Identifier()
        elif choice == 19:
            current += self.unlexer.Identifier()
        elif choice == 20:
            current += self.unlexer.Identifier()
        elif choice == 21:
            current += self.unlexer.Identifier()
        elif choice == 22:
            current += self.unlexer.Identifier()
        elif choice == 23:
            current += self.unlexer.Identifier()
        elif choice == 24:
            current += self.unlexer.Identifier()
        elif choice == 25:
            current += self.unlexer.Identifier()
        elif choice == 26:
            current += self.unlexer.Identifier()
        elif choice == 27:
            current += self.unlexer.Identifier()
        elif choice == 28:
            current += self.unlexer.Identifier()
        elif choice == 29:
            current += self.unlexer.Identifier()
        elif choice == 30:
            current += self.unlexer.Identifier()
        elif choice == 31:
            current += self.unlexer.Identifier()
        elif choice == 32:
            current += self.unlexer.Identifier()
        elif choice == 33:
            current += self.unlexer.Identifier()
        elif choice == 34:
            current += self.unlexer.Identifier()
        elif choice == 35:
            current += self.unlexer.Identifier()
        elif choice == 36:
            current += self.unlexer.Identifier()
        elif choice == 37:
            current += self.unlexer.Identifier()
        return current
    simpleIdentifier.min_depth = 1

    @depthcontrol
    def semi(self):
        current = self.create_node(UnparserRule(name='semi'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_4033', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_4033', choice)] = self.unlexer.weights.get(('alt_4033', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.NL()

        elif choice == 1:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

            current += self.unlexer.SEMICOLON()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.NL()

        return current
    semi.min_depth = 1

    @depthcontrol
    def anysemi(self):
        current = self.create_node(UnparserRule(name='anysemi'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_4038', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_4038', choice)] = self.unlexer.weights.get(('alt_4038', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NL()
        elif choice == 1:
            current += self.unlexer.SEMICOLON()
        return current
    anysemi.min_depth = 1

    default_rule = kotlinFile

